# Goldbach의 추측 노트

## 문제 개요
- **문제 설명:**  
  주어진 짝수(예: `inm`)를 두 소수의 합으로 나타내는 문제입니다.  
  골드바흐의 추측에 따르면, 2보다 큰 모든 짝수는 두 소수의 합으로 표현될 수 있습니다.
  
- **특별 조건:**  
  가능한 경우 중 두 소수의 차이가 최소가 되는, 즉 두 소수가 서로 최대한 가까운 경우를 출력해야 합니다.

## 알고리즘 설명

### 1. 소수 판별 함수 `is_prime(num)`
- **목적:**  
  주어진 정수 `num`이 소수인지 여부를 판별합니다.
- **구현 방법:**  
  - `num`이 2 미만이면 소수가 아님.
  - 2부터 `√num`까지의 수로 나누어 떨어지는지 확인.
  - 하나라도 나누어 떨어지면 소수가 아니며, 그렇지 않으면 소수로 판단.

```python
def is_prime(num):
    if num < 2:
        return False
    for i in range(2, int(num**0.5) + 1):
        if num % i == 0:
            return False
    return True
```

### 2. 골드바흐 파티션 찾기
- **목표:**  
  입력된 짝수를 두 소수의 합으로 나타내되, 두 소수의 차이가 최소인 경우를 찾습니다.
  
- **접근 방법:**  
  - 두 소수의 차이가 최소가 되려면, 두 소수가 \( \frac{inm}{2} \)에 가까워야 합니다.
  - 따라서, 후보 소수 `i`를 **\( \frac{inm}{2} \)에서부터 내려가는 순서**로 검사합니다.
  - 이 방식은 `reversed(range(2, int(inm/2)+1))`를 사용합니다.

- **순서의 중요성:**  
  - **reversed 사용 시:**  
    가장 중앙값에 가까운 후보부터 검사하므로, 예를 들어 `10`일 경우 먼저 `5`를 검사해 (5, 5)를 출력하게 됩니다.
  - **순방향 사용 시:**  
    작은 소수부터 검사하게 되어 (3, 7)처럼 중앙에서 멀어진 경우가 먼저 발견됩니다.

```python
for t in range(int(input())):
    inm = int(input())
    # 가장 차이가 작은 소수 쌍을 찾기 위해 in_m/2에 가까운 수부터 검사
    for i in reversed(range(2, int(inm/2)+1)):
        if is_prime(i) and is_prime(inm-i):
            print(i, inm-i)
            break
```

## 예제
- **입력:**  
  ```
  1
  10
  ```
- **출력:**  
  ```
  5 5
  ```
- **설명:**  
  10의 경우, 10/2인 5부터 시작하여 5와 10-5(5)가 모두 소수임을 확인합니다.  
  이 경우 두 소수의 차이가 0으로 최소가 됩니다.

## 핵심 포인트
- **골드바흐의 추측:**  
  2보다 큰 모든 짝수는 두 소수의 합으로 표현 가능하다는 가설입니다.
- **최적 쌍 선택:**  
  두 소수의 차이가 최소가 되도록 \( \frac{inm}{2} \) 근처의 소수를 우선으로 탐색합니다.
- **반복 순서의 중요성:**  
  탐색 순서를 reversed로 설정해야 문제의 조건(최소 차이)이 만족됩니다.
