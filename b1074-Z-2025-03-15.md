# Z 문제 노트

## 문제 개요
- **문제 설명:**  
  크기가 \(2^N \times 2^N\)인 2차원 배열을 Z 모양으로 탐색하는 문제입니다.  
  예를 들어, 2×2 배열의 경우 왼쪽 위, 오른쪽 위, 왼쪽 아래, 오른쪽 아래 순서로 방문하면 Z 모양이 됩니다.

- **문제 조건:**  
  - N > 1인 경우, 배열을 크기가 \(2^{N-1} \times 2^{N-1}\)인 4개의 사분면으로 나눈 후 재귀적으로 순서대로 방문합니다.
  - 입력으로 N, r, c가 주어지며, r행 c열이 몇 번째로 방문되는지를 출력합니다.

## 알고리즘 설명
이 문제는 분할 정복(재귀)을 활용하여 해결할 수 있습니다.

1. **배열 분할:**  
   - 배열의 크기는 \(2^N \times 2^N\)이며, 이를 네 개의 사분면(각각의 크기는 \(2^{N-1} \times 2^{N-1}\))으로 분할합니다.

2. **재귀적 탐색:**  
![사분면 다이어그램](assets/Screenshot-b1074-1.png)
   - 각 사분면의 방문 순서는 다음과 같이 결정됩니다:
     - **1사분면 (왼쪽 위):** `row < half` 그리고 `column < half`
     - **2사분면 (오른쪽 위):** `row < half` 그리고 `column >= half`
     - **3사분면 (왼쪽 아래):** `row >= half` 그리고 `column < half`
     - **4사분면 (오른쪽 아래):** 나머지 경우
   - 각 사분면마다 해당 사분면의 크기(\(half^2\))에 따라 방문 순서의 시작 번호(오프셋)가 결정됩니다.
   - 재귀 호출을 통해 최종적으로 r행 c열의 방문 순서를 계산합니다.

## 코드 

```python
def z(n, row, column):
    if n == 0:
        return 0
    half = (2**n) // 2  # 2^(n-1): 각 사분면의 한 변의 길이
    # 사분면에 따라 재귀 호출과 오프셋 추가
    if row < half and column < half:       # 1사분면
        return z(n-1, row, column)
    elif row < half and column >= half:      # 2사분면
        return (half**2) + z(n-1, row, column - half)
    elif row >= half and column < half:      # 3사분면
        return (half**2)*2 + z(n-1, row - half, column)
    else:                                   # 4사분면
        return (half**2)*3 + z(n-1, row - half, column - half)

# 입력 처리 및 결과 출력
n, r, c = map(int, input().split())
print(z(n, r, c))
```

## 예제

- **입력:**  
  ```
  2 3 1
  ```
- **출력:**  
  출력값은 문제에서 정의한 Z 순서에 따라 결정되며, 예를 들어 위 입력의 경우 방문 순서 번호가 출력됩니다.

## 핵심 포인트
- **분할 정복:**  
  큰 문제를 4개의 작은 문제로 나누어 해결하는 방식입니다.
- **재귀:**  
  문제를 재귀적으로 해결하여, 각 사분면 내에서의 위치를 계산합니다.
- **오프셋 계산:**  
  각 사분면의 크기(\(half^2\))를 활용해, 방문 순서의 시작 번호를 결정합니다.

---

이 문제는 재귀와 분할정복에 대해서 다루었습니다.
